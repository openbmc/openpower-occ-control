// This file was autogenerated.  Do not edit!
// See elog-gen.py for more details
#pragma once

#include <string>
#include <tuple>
#include <type_traits>
#include <sdbusplus/exception.hpp>
#include <phosphor-logging/log.hpp>
#include <phosphor-logging/elog.hpp>

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace OCC
{
namespace PassThrough
{
namespace Error
{
    struct ReadFailure;
} // namespace Error
} // namespace PassThrough
} // namespace OCC
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace OCC
{
namespace PassThrough
{
namespace Error
{
    struct WriteFailure;
} // namespace Error
} // namespace PassThrough
} // namespace OCC
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace OCC
{
namespace Device
{
namespace Error
{
    struct Failure;
} // namespace Error
} // namespace Device
} // namespace OCC
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace OCC
{
namespace PassThrough
{
namespace Error
{
    struct OpenFailure;
} // namespace Error
} // namespace PassThrough
} // namespace OCC
} // namespace open_power
} // namespace org
} // namespace sdbusplus


namespace phosphor
{

namespace logging
{

namespace org
{
namespace open_power
{
namespace OCC
{
namespace Device
{
namespace _Failure
{

struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _Failure

struct Failure : public sdbusplus::exception_t
{
    static constexpr auto errName = "org.open_power.OCC.Device.Failure";
    static constexpr auto errDesc = "A device operation failed.";
    static constexpr auto L = level::INFO;
    using ERRNO = _Failure::ERRNO;
    using metadata_types = std::tuple<ERRNO>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Device
} // namespace OCC
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::OCC::Device::Error::Failure>
{
    using type = org::open_power::OCC::Device::Failure;
};

}

namespace org
{
namespace open_power
{
namespace OCC
{
namespace PassThrough
{
namespace _OpenFailure
{


}  // namespace _OpenFailure

struct OpenFailure : public sdbusplus::exception_t
{
    static constexpr auto errName = "org.open_power.OCC.PassThrough.OpenFailure";
    static constexpr auto errDesc = "Opening OCC device failed.";
    static constexpr auto L = level::INFO;
    using ERRNO = org::open_power::OCC::Device::Failure::ERRNO;
    using metadata_types = std::tuple<ERRNO>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace PassThrough
} // namespace OCC
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::OCC::PassThrough::Error::OpenFailure>
{
    using type = org::open_power::OCC::PassThrough::OpenFailure;
};

}

namespace org
{
namespace open_power
{
namespace OCC
{
namespace PassThrough
{
namespace _ReadFailure
{


}  // namespace _ReadFailure

struct ReadFailure : public sdbusplus::exception_t
{
    static constexpr auto errName = "org.open_power.OCC.PassThrough.ReadFailure";
    static constexpr auto errDesc = "Reading from OCC failed.";
    static constexpr auto L = level::INFO;
    using ERRNO = org::open_power::OCC::Device::Failure::ERRNO;
    using metadata_types = std::tuple<ERRNO>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace PassThrough
} // namespace OCC
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::OCC::PassThrough::Error::ReadFailure>
{
    using type = org::open_power::OCC::PassThrough::ReadFailure;
};

}

namespace org
{
namespace open_power
{
namespace OCC
{
namespace PassThrough
{
namespace _WriteFailure
{


}  // namespace _WriteFailure

struct WriteFailure : public sdbusplus::exception_t
{
    static constexpr auto errName = "org.open_power.OCC.PassThrough.WriteFailure";
    static constexpr auto errDesc = "Writing to OCC failed.";
    static constexpr auto L = level::INFO;
    using ERRNO = org::open_power::OCC::Device::Failure::ERRNO;
    using metadata_types = std::tuple<ERRNO>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace PassThrough
} // namespace OCC
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::OCC::PassThrough::Error::WriteFailure>
{
    using type = org::open_power::OCC::PassThrough::WriteFailure;
};

}

} // namespace logging

} // namespace phosphor
